# HTB-nopeeking writeup
HTB - nopeeking writeup

Первым делом открываем бинарь в IDA и смотрим что он из себя представляет. Из беглого статического анализа видно, что бинарь богат функциями ptrace, а также в самом начале main функции присутствует fork, т.е., скорее всего будем иметь дело с межпроцессорным взаимодействием.

(далее я буду объяснять на примере уже разобранного мной бинаря, т.е. в нем будут присутствовать мои обозначения имен функций и переменных)

Итак, в главной функции присутствуют 2 блока кода, которые выполняются в зависимости от рода процесса (дочерний\родительский)
![parent_child_nachalo](https://github.com/VladimirAnderson/HTB---nopeeking-writeup/assets/57271893/6ca89674-75f6-44ec-b446-d84e07ae7c6d)

В начале своего исполнения, родительский процесс переходит в режим ожидания дочернего процесса, выполняя бесконечный цикл(функция infinite_xor_canary)
В то же время дочерний процесс исполняет функцию parent_process_attach в которой он начинает отлаживать родителя и выводит его из спячки:
![parent_process_attach](https://github.com/VladimirAnderson/HTB---nopeeking-writeup/assets/57271893/9af88592-6a57-4533-85d2-dad279cccd25)

Здесь я должен сделать замечание: Т.к. процессы находятся во взаимной отладке, то трассировать такую программу будет практически нереально рядовыми средствами отладки без потери информационного контекста(я долгое время пытался использовать gdb, отлаживая родительский и дочерний процесс по отдельности, используя функции set follow-fork-mode parent/child, но практически ни к чему я не пришел; более того, утилиты трассировки, к примеру -  strace, сразу же отлетают, т.к. их работа основана на ptrace-вызовах , а процессы уже под отладкой.)

Идем дальше. В обоих блоках кода пристутствуют практически одинаковые функции в которых как раз и происходит весь движ: межпроцессорное общение и проверка нашего флага:
![dvij](https://github.com/VladimirAnderson/HTB---nopeeking-writeup/assets/57271893/637cb2e3-cc10-4b43-87fa-26ac9d68b45e)

Межпроцессорное взаимодействие реализовано через функцию process_handling, рассмотрим её:
![proc_handling](https://github.com/VladimirAnderson/HTB---nopeeking-writeup/assets/57271893/8982cabe-f5cd-4c24-8115-db161ee5ecc0)

В данной функции происходит чтение определенных байтов из памяти отлаживаемого процесса и, исходя из полученных байтов, производится то или иное действие.
Чтение байтов производится из кода функций, в которых происходит проверка части флага - check1 and check2:

![0f0b](https://github.com/VladimirAnderson/HTB---nopeeking-writeup/assets/57271893/9194d947-4fd2-471e-874e-1f2008c047dc)
![0f0bf](https://github.com/VladimirAnderson/HTB---nopeeking-writeup/assets/57271893/75fd876b-d370-4f8f-aa39-8aa837218b3f)

 
Рассмотрим функцию check1(), она практически аналогична check2().
В данной функции реализована проверка половины флага 
Можно увидеть, что в регистре ecx хранится преобразованное значение, которое проверяется данной функцией и было бы неплохо его перехватить в этот момент:
![key_moment](https://github.com/VladimirAnderson/HTB---nopeeking-writeup/assets/57271893/dc518dfb-b1a1-47f7-8c6e-cadd16de2631)

Как я уже говорил, отладчиком нам это не сделать, поэтому здесь я воспользовался инструментом frida-trace(можно также было попробовать реализовать hook через LD_PRELOAD, однако у меня он не сработал...)
Хукаем функцию putchar, т.к. от неё можно спокойно дотянуться до данного регистра:
![frida_hook](https://github.com/VladimirAnderson/HTB---nopeeking-writeup/assets/57271893/a4ff15ed-a60d-4ec9-8c81-1ca8be52d15e)

Пробуем ввести комбинацию: HTB{qweqweqweqweqweqwe} и видим, что у первых 3х символов флаг RAX взведен, а значения RCX по модулю 0x100 совпадают со значениями массива, хранящего зашифрованную часть флага.
![frida_trace_result](https://github.com/VladimirAnderson/HTB---nopeeking-writeup/assets/57271893/bf4fe0e6-dd98-407c-81ad-cc94290bdee3)

Однако при простом прогоне программы выводится 27 точек, в нашем случае frida перехватила всего-лишь 13 выводов точек, т.е. 13 вызовов функции putchar. Все дело в массиве gamma , который является маской, определяющей, с какой части флага(с какого массива, содержащего часть флага = с какого процесса) будет сравниваться очередной символ с нашим преобразованным значением.(Frida-trace, видимо, перехватывает функции только от 1 процесса... Но это нам не мешает понять всю суть :) ). При написании скрипта, дешифрующего флаг я опытным путем установил, что при очередном значении =0 из массива gamma , символ берется из 2й части зашифрованного флага, а при значении 1, соответственно, из 1й части.
![massives](https://github.com/VladimirAnderson/HTB---nopeeking-writeup/assets/57271893/92b42f49-5c30-48c6-902e-0fc2a6f0a195)

Исходя из полученных данных, пишем декриптор, кстати, операция шифрования находится в функции  process_handling; она в принципе и единственная в этом бинаре, которая как-то шифрует  данные, поэтому даже думать по поводу алгоритма шифрования программы и не надо)
Собсна, декриптор-с : ) https://github.com/VladimirAnderson/HTB---nopeeking-writeup/blob/main/flag.py
